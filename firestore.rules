/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a multi-tenant security model for the Whizly AI application.
 * All data is segregated by tenant, and access is controlled based on user roles and explicit account access permissions.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores tenant-specific data.
 * - /users/{userId}: Stores user profiles.
 * - /tenants/{tenantId}/leads/{leadId}: Stores lead data.
 * - /tenants/{tenantId}/chatbotAgents/{agentId}: Stores ChatbotAgent data.
 * - /tenants/{tenantId}/conversations/{conversationId}: Stores conversation data.
 * - /tenants/{tenantId}/accountAccess/{accessId}: Stores account access control data.
 *
 * Key Security Decisions:
 * - Listing of users is disallowed to prevent unauthorized enumeration.
 * - Tenant-based segregation ensures data isolation.
 * - AccountAccess documents explicitly grant/revoke permissions, enabling fine-grained access control.
 *
 * Denormalization for Authorization:
 * - The `AccountAccess` collection denormalizes user and lead relationships to enable efficient permission checks without requiring additional `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants tenant owners full access to their tenant data.
     * @path /tenants/{tenantId}
     * @allow (create) User with matching {tenantId} can create a tenant.
     * @deny (create) User without matching {tenantId} cannot create a tenant.
     * @allow (get) Any authenticated user can read tenant data.
     * @deny (list) Listing tenants is not allowed.
     * @principle Enforces document ownership for writes.
     */
    match /tenants/{tenantId} {
      function isOwner(tenantId) {
        return request.auth.uid == resource.data.ownerId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if false;

      allow create: if request.auth.uid == request.resource.data.ownerId;
      allow update: if request.auth.uid == resource.data.ownerId;
      allow delete: if request.auth.uid == resource.data.ownerId;
    }

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) User can create their own profile.
     * @deny (create) User cannot create another user's profile.
     * @allow (get) User can read their own profile.
     * @deny (get) User cannot read another user's profile.
     * @allow (list) Listing users is not allowed.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to lead data within a tenant.
     * @path /tenants/{tenantId}/leads/{leadId}
     * @allow (create) Tenant owner can create leads.
     * @deny (create) User cannot create leads in another tenant.
     * @allow (get) Any authenticated user can read lead data if they have access (TODO: implement access checks).
     * @deny (list) Listing leads requires tenant membership (TODO: implement access checks).
     * @principle Enforces tenant-based data segregation.
     */
    match /tenants/{tenantId}/leads/{leadId} {
      function isTenantOwner(tenantId) {
        return get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn(); // TODO: Implement granular access check based on AccountAccess
      allow list: if false; // TODO: Implement granular access check based on AccountAccess

      allow create: if isTenantOwner(tenantId);
      allow update: if get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
      allow delete: if get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Controls access to chatbot agent data within a tenant.
     * @path /tenants/{tenantId}/chatbotAgents/{agentId}
     * @allow (create) Tenant owner can create chatbot agents.
     * @deny (create) User cannot create chatbot agents in another tenant.
     * @allow (get) Any authenticated user can read chatbot agent data if they have access (TODO: implement access checks).
     * @deny (list) Listing chatbot agents requires tenant membership (TODO: implement access checks).
     * @principle Enforces tenant-based data segregation.
     */
    match /tenants/{tenantId}/chatbotAgents/{agentId} {
      function isTenantOwner(tenantId) {
        return get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn(); // TODO: Implement granular access check based on AccountAccess
      allow list: if false; // TODO: Implement granular access check based on AccountAccess

      allow create: if isTenantOwner(tenantId);
      allow update: if get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
      allow delete: if get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Controls access to conversation data within a tenant.
     * @path /tenants/{tenantId}/conversations/{conversationId}
     * @allow (create) Tenant owner can create conversations.
     * @deny (create) User cannot create conversations in another tenant.
     * @allow (get) Any authenticated user can read conversation data if they have access (TODO: implement access checks).
     * @deny (list) Listing conversations requires tenant membership (TODO: implement access checks).
     * @principle Enforces tenant-based data segregation.
     */
    match /tenants/{tenantId}/conversations/{conversationId} {
      function isTenantOwner(tenantId) {
        return get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn(); // TODO: Implement granular access check based on AccountAccess
      allow list: if false; // TODO: Implement granular access check based on AccountAccess

      allow create: if isTenantOwner(tenantId);
      allow update: if get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
      allow delete: if get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Controls access to account access data within a tenant.
     * @path /tenants/{tenantId}/accountAccess/{accessId}
     * @allow (create) Tenant owner can create account access entries.
     * @deny (create) User cannot create account access entries in another tenant.
     * @allow (get) Any authenticated user can read account access data if they have access (TODO: implement access checks).
     * @deny (list) Listing account access entries requires tenant membership (TODO: implement access checks).
     * @principle Enforces tenant-based data segregation and explicit account access control.
     */
    match /tenants/{tenantId}/accountAccess/{accessId} {
      function isTenantOwner(tenantId) {
        return get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn(); // TODO: Implement granular access check based on AccountAccess
      allow list: if false; // TODO: Implement granular access check based on AccountAccess

      allow create: if isTenantOwner(tenantId);
      allow update: if get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
      allow delete: if get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
    }
  }
}