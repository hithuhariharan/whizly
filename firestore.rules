/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a multi-tenant security model with role-based access control for the Whizly AI application.
 *
 * Core Philosophy:
 *  - Strict ownership and explicit access control are enforced to protect tenant data.
 *  - Rules are designed for authorization independence, avoiding `get()` calls.
 *  - The AccountAccess collection is central to granting/revoking access to leads and conversations.
 *
 * Data Structure:
 *  - /tenants/{tenantId}: Root for all tenant-specific data.
 *  - /users/{userId}: Stores user profiles.
 *  - /tenants/{tenantId}/leads/{leadId}: Leads belonging to a tenant.
 *  - /tenants/{tenantId}/chatbotAgents/{agentId}: Chatbot agents for a tenant.
 *  - /tenants/{tenantId}/conversations/{conversationId}: Conversations related to leads within a tenant.
 *  - /tenants/{tenantId}/accountAccess/{accessId}: Explicitly models account access for leads.
 *
 * Key Security Decisions:
 *  - Users cannot list all users; listing is only allowed within a specific tenant context, if needed.
 *  - The AccountAccess collection explicitly grants/revokes access to leads and conversations, enabling granular control.
 *
 * Denormalization for Authorization:
 *  - The AccountAccess documents contain `userId` and `leadId` to allow rules to directly check access permissions without additional reads.
 *
 * Structural Segregation:
 *  - Data is segregated by tenant to prevent unauthorized access between tenants.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return request.auth.uid == resource.data.ownerId;
    }

    /**
     * @description Allows read and write access to tenant documents, with owner-only writes.
     * @path /tenants/{tenantId}
     * @allow (create) request.auth.uid can create a tenant with request.resource.data.ownerId == request.auth.uid.
     * @deny (create) request.auth.uid cannot create a tenant with request.resource.data.ownerId != request.auth.uid.
     */
    match /tenants/{tenantId} {
      allow get: if true;
      allow list: if false; // Listing tenants is not permitted

      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.ownerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.ownerId);

      match /leads/{leadId} {
        function canViewLead(tenantId, leadId, userId) {
            return exists(/databases/$(database)/documents/tenants/$(tenantId)/accountAccess/$(leadId)_$(userId))
                && get(/databases/$(database)/documents/tenants/$(tenantId)/accountAccess/$(leadId)_$(userId)).data.canViewChat == true;
        }

        function canEditLead(tenantId, leadId, userId) {
            return exists(/databases/$(database)/documents/tenants/$(tenantId)/accountAccess/$(leadId)_$(userId))
                && get(/databases/$(database)/documents/tenants/$(tenantId)/accountAccess/$(leadId)_$(userId)).data.canEditLead == true;
        }
        
        allow get: if isSignedIn() && canViewLead(tenantId, leadId, request.auth.uid);
        allow list: if false; // Listing of leads should be controlled elsewhere

        allow create: if isSignedIn();
        allow update: if isSignedIn() && canEditLead(tenantId, leadId, request.auth.uid);
        allow delete: if isSignedIn() && canEditLead(tenantId, leadId, request.auth.uid);
      }

      match /chatbotAgents/{agentId} {
          function isTenantOwner(tenantId) {
              return get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
          }
        allow get: if isSignedIn() && isTenantOwner(tenantId);
        allow list: if isSignedIn() && isTenantOwner(tenantId);

        allow create: if isSignedIn() && isTenantOwner(tenantId);
        allow update: if isSignedIn() && isTenantOwner(tenantId);
        allow delete: if isSignedIn() && isTenantOwner(tenantId);
      }

      match /conversations/{conversationId} {
          function canViewConversation(tenantId, leadId, userId) {
              return exists(/databases/$(database)/documents/tenants/$(tenantId)/accountAccess/$(leadId)_$(userId))
                  && get(/databases/$(database)/documents/tenants/$(tenantId)/accountAccess/$(leadId)_$(userId)).data.canViewChat == true;
          }

          function getLeadId() {
            return request.resource.data.leadId;
          }

        allow get: if isSignedIn() && canViewConversation(tenantId, getLeadId(), request.auth.uid);
        allow list: if false; // Listing conversations is not permitted directly

        allow create: if isSignedIn() ;
        allow update: if isSignedIn() && canViewConversation(tenantId, getLeadId(), request.auth.uid);
        allow delete: if isSignedIn() && canViewConversation(tenantId, getLeadId(), request.auth.uid);
      }

      match /accountAccess/{accessId} {
         function isTenantOwner(tenantId) {
              return get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
          }
        allow get: if isSignedIn() && isTenantOwner(tenantId);
        allow list: if isSignedIn() && isTenantOwner(tenantId);

        allow create: if isSignedIn() && isTenantOwner(tenantId);
        allow update: if isSignedIn() && isTenantOwner(tenantId);
        allow delete: if isSignedIn() && isTenantOwner(tenantId);
      }
    }

    /**
     * @description Allows read and write access to user documents, with owner-only access.
     * @path /users/{userId}
     * @allow (create) request.auth.uid can create their own user document.
     * @deny (update) request.auth.uid cannot update another user's document.
     * @principle Enforces user-owned data trees
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }
  }
}