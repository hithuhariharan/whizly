/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a multi-tenant security model where data access is strictly controlled within each tenant.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Root collection for tenants.
 * - /users/{userId}: Root collection for users. User documents store tenant membership.
 * - /tenants/{tenantId}/leads/{leadId}: Leads belonging to a specific tenant.
 * - /tenants/{tenantId}/chatbotAgents/{agentId}: Chatbot agents for each tenant.
 * - /tenants/{tenantId}/conversations/{conversationId}: Conversations related to leads within a tenant.
 * - /tenants/{tenantId}/accountAccess/{accessId}: Explicit access control list for lead access.
 *
 * Key Security Decisions:
 * - User listing is implicitly denied as there is no rule allowing listing the `/users` collection.
 * - All data is scoped to tenants, preventing cross-tenant data access.
 * - `accountAccess` collection is used to authorize access to leads and conversations.
 *
 * Denormalization for Authorization:
 * - The `accountAccess` collection denormalizes user and lead relationships to allow efficient authorization checks without needing `get()` calls.
 *
 * Structural Segregation:
 * - Tenant-specific data is stored in separate subcollections under each tenant, ensuring data isolation.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows managing tenants, restricting access to the tenant owner.
     * @path /tenants/{tenantId}
     * @allow (create) User with matching {tenantId} can create a tenant document.
     * @deny (create) User without matching {tenantId} cannot create a tenant document.
     * @allow (get, list) Anyone can read tenant information.
     * @allow (update, delete) Only the owner can update or delete the tenant.
     * @deny (update, delete) Others cannot update or delete the tenant.
     * @principle Enforces tenant ownership for writes.
     */
    match /tenants/{tenantId} {
      // Read permissions: Public read
      allow get, list: if true;

      // Write permissions: Owner-only writes

      // Self-Creation: Allow create if the authenticated user's UID matches the tenant's ownerId
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;

      // Owner-Only Access: Update and delete are restricted to the tenant owner.
      allow update, delete: if isSignedIn() && get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Allows managing user profiles, restricting write access to the user themselves.
     * @path /users/{userId}
     * @allow (create) User can create their own profile.
     * @deny (create) User cannot create another user's profile.
     * @allow (get) Anyone can read user information.
     * @deny (list) Listing of users is not allowed.
     * @allow (update, delete) User can update or delete their own profile.
     * @deny (update, delete) User cannot update or delete another user's profile.
     * @principle Enforces user ownership for writes.
     */
    match /users/{userId} {
      // Read permissions: Public read for get, no list
      allow get: if true;
      allow list: if false; // Listing users is not permitted.

      // Write permissions: Owner-only writes

      // Self-Creation: Allow create if the authenticated user's UID matches the document ID.
      allow create: if isSignedIn() && request.auth.uid == userId;

      // Owner-Only Access: Update and delete are restricted to the user themselves.
      allow update, delete: if isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Allows managing leads within a tenant, restricting access based on account access controls.
     * @path /tenants/{tenantId}/leads/{leadId}
     * @allow (create) Anyone can create a lead within a tenant. Requires tenantId match.
     * @deny (create) Creating leads in the wrong tenant is denied.
     * @allow (get) Anyone can read lead information if they have access.
     * @allow (list) Anyone can list leads if they have access.
     * @allow (update, delete) Only users with `canEditLead` can update or delete a lead.
     * @deny (update, delete) Users without `canEditLead` cannot update or delete a lead.
     * @principle Enforces access control through the AccountAccess collection.
     */
    match /tenants/{tenantId}/leads/{leadId} {
      // Read permissions: Check AccountAccess
      allow get: if isSignedIn() && hasLeadAccess(tenantId, leadId, request.auth.uid, 'canViewChat');
      allow list: if isSignedIn() && hasLeadAccess(tenantId, leadId, request.auth.uid, 'canViewChat');

      // Write permissions: Check AccountAccess for edit permission
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
      allow update, delete: if isSignedIn() && hasLeadAccess(tenantId, leadId, request.auth.uid, 'canEditLead');
    }

    /**
     * @description Allows managing chatbot agents within a tenant.
     * @path /tenants/{tenantId}/chatbotAgents/{agentId}
     * @allow (create) Anyone can create an agent within a tenant.
     * @deny (create) Creating agents in the wrong tenant is denied.
     * @allow (get, list) Anyone can read chatbot agent information.
     * @allow (update, delete) Only the owner can update or delete the agent.
     * @deny (update, delete) Others cannot update or delete the agent.
     */
    match /tenants/{tenantId}/chatbotAgents/{agentId} {
      // Read permissions: Public read
      allow get, list: if true;

      // Write permissions: Only users in the tenant can write.
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
      allow update, delete: if isSignedIn() && isTenantMember(tenantId);
    }

    /**
     * @description Allows managing conversations within a tenant, restricting access based on lead access controls.
     * @path /tenants/{tenantId}/conversations/{conversationId}
     * @allow (create) Anyone can create a conversation within a tenant if they have access to the lead.
     * @deny (create) Creating conversations in the wrong tenant is denied.
     * @allow (get) Anyone can read conversation information if they have access to the lead.
     * @allow (list) Anyone can list conversations if they have access to the associated lead.
     * @allow (update, delete) Only users with `canEditLead` can update or delete a conversation.
     * @deny (update, delete) Users without `canEditLead` cannot update or delete a conversation.
     */
    match /tenants/{tenantId}/conversations/{conversationId} {
      // Read permissions: Check AccountAccess for the associated lead.
      allow get: if isSignedIn() && get(/databases/$(database)/documents/tenants/$(tenantId)/conversations/$(conversationId)).data.leadId != null && hasLeadAccess(tenantId, get(/databases/$(database)/documents/tenants/$(tenantId)/conversations/$(conversationId)).data.leadId, request.auth.uid, 'canViewChat');
      allow list: if isSignedIn() && get(/databases/$(database)/documents/tenants/$(tenantId)/conversations/$(conversationId)).data.leadId != null && hasLeadAccess(tenantId, get(/databases/$(database)/documents/tenants/$(tenantId)/conversations/$(conversationId)).data.leadId, request.auth.uid, 'canViewChat');

      // Write permissions: Check AccountAccess for the associated lead for edit permission.
      allow create: if isSignedIn() && request.resource.data.leadId != null && isLeadInTenant(tenantId, request.resource.data.leadId);
      allow update, delete: if isSignedIn() && get(/databases/$(database)/documents/tenants/$(tenantId)/conversations/$(conversationId)).data.leadId != null && hasLeadAccess(tenantId, get(/databases/$(database)/documents/tenants/$(tenantId)/conversations/$(conversationId)).data.leadId, request.auth.uid, 'canEditLead');
    }

    /**
     * @description Allows managing account access controls within a tenant.
     * @path /tenants/{tenantId}/accountAccess/{accessId}
     * @allow (create) Anyone can create an account access entry within a tenant.
     * @deny (create) Creating account access entries in the wrong tenant is denied.
     * @allow (get, list) Anyone can read account access information.
     * @allow (update, delete) Only the tenant owner can update or delete account access entries.
     * @deny (update, delete) Others cannot update or delete account access entries.
     */
    match /tenants/{tenantId}/accountAccess/{accessId} {
      // Read permissions: Public read.
      allow get, list: if true;

      // Write permissions: Only tenant owner can manage access.
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
      allow update, delete: if isSignedIn() && isTenantOwner(tenantId);
    }
  }

  // Helper functions

  // Checks if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }

  // Checks if the user is the owner of the tenant.
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  // Checks if the user is a member of the tenant.
  function isTenantMember(tenantId) {
    return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantIds is list && tenantId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantIds;
  }

    // Checks if the user is the owner of the tenant.
  function isTenantOwner(tenantId) {
    return get(/databases/$(database)/documents/tenants/$(tenantId)).data.ownerId == request.auth.uid;
  }

  // Checks if the user has access to a lead based on AccountAccess.
  function hasLeadAccess(tenantId, leadId, userId, permission) {
    return exists(/databases/$(database)/documents/tenants/$(tenantId)/accountAccess/$(userId)_$(leadId)) &&
           get(/databases/$(database)/documents/tenants/$(tenantId)/accountAccess/$(userId)_$(leadId)).data[permission] == true;
  }

  // Checks if a lead exists and belongs to the specified tenant.
  function isLeadInTenant(tenantId, leadId) {
    return exists(/databases/$(database)/documents/tenants/$(tenantId)/leads/$(leadId));
  }
}