/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a multi-tenant security model for the Whizly AI application.
 * All data is segregated by tenant, and access is controlled through a combination of ownership
 * and explicit account access grants.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores tenant-specific data, accessible to tenant owners.
 * - /users/{userId}: Stores user profiles, accessible only to the user themselves.
 * - /tenants/{tenantId}/leads/{leadId}: Stores lead data within a tenant, with access controlled
 *   by tenant membership and explicit account access grants.
 * - /tenants/{tenantId}/chatbotAgents/{agentId}: Stores chatbot agent data within a tenant.
 * - /tenants/{tenantId}/conversations/{conversationId}: Stores conversation data within a tenant,
 *   linked to leads.
 * - /tenants/{tenantId}/accountAccess/{accessId}: Stores explicit account access grants for leads,
 *   allowing control over who can view chats and edit leads.
 *
 * Key Security Decisions:
 * - Users can only read/write their own user profiles.
 * - Listing of users is denied.
 * - All other collections are tenant-scoped, with access based on tenant membership and
 *   explicit account access grants.
 *
 * Denormalization for Authorization:
 * - The `accountAccess` collection denormalizes permissions to avoid `get()` calls. Rules on
 *   `/tenants/{tenantId}/conversations/{conversationId}` can check the `accountAccess` collection
 *   to ensure the requesting user has `canViewChat` permission for the associated lead before
 *   allowing access to conversation messages.
 *
 * Structural Segregation:
 * - Sensitive data is stored in tenant-specific subcollections, preventing unauthorized listing.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by a signed-in user.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {bool} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of an existing document.
     * @param {string} userId The user ID of the document's owner.
     * @return {bool} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Grants or revokes `canViewChat` and `canEditLead` permissions on a per-user, per-lead basis.
     * @path /tenants/{tenantId}
     * @allow (create) if isSignedIn() && request.auth.uid == request.resource.data.ownerId
     * @deny (create) if !isSignedIn()
     * @principle Enforces tenant ownership for writes
     */
    match /tenants/{tenantId} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.ownerId;
      allow update: if false; // TODO: add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores user profiles. Users can only read/write their own profile.
     * @path /users/{userId}
     * @allow (get) if isOwner(userId)
     * @deny (get) if !isOwner(userId)
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Stores lead data. Access is tenant-scoped.
     * @path /tenants/{tenantId}/leads/{leadId}
     */
    match /tenants/{tenantId}/leads/{leadId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores ChatbotAgent data, segregated by tenant.
     * @path /tenants/{tenantId}/chatbotAgents/{agentId}
     */
    match /tenants/{tenantId}/chatbotAgents/{agentId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores conversation data. Segregated by tenant and linked to leads.
     * @path /tenants/{tenantId}/conversations/{conversationId}
     */
    match /tenants/{tenantId}/conversations/{conversationId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

     /**
      * @description Explicitly models account access at the tenant level.  Grants/revokes `canViewChat` and `canEditLead` permissions on a per-user, per-lead basis.
      * @path /tenants/{tenantId}/accountAccess/{accessId}
      */
    match /tenants/{tenantId}/accountAccess/{accessId} {
      allow get: if true;
      allow list: if true;
      allow create: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}